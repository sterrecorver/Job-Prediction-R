---
title: "Project"
author: "Sterre Corver and Tim van der Valk"
date: "2023-02-22"
output:
  prettydoc::html_pretty:
      theme: leonids
      highlights: github
---

```{r setup, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r echo=FALSE}
library(janitor)
library(tidyverse)
library(ggplot2)
library(dplyr)
library(knitr)
library(tidyr)
library(scales)
library(tidymodels)
library(rpart)
library(rpart.plot)
library(ggcorrplot)
library(corrplot)
library(gridExtra)
library(glue)
```

We upload the dataset in R, and make sure that the variable names that consist of more than 1 word, there will be placed an _ between the words. 

```{r}
data <- read.csv("job_search_dataset.csv") %>% clean_names()
```

**Pre-processing**
Remove the variables employee_count, standard_hours and over18 since they have the same value for all the observations so they won't be interesting to use in our prediction.

```{r}
df <- subset(data, select = -c(employee_count, standard_hours, over18))
```

Now we transform the binary variables answered with yes/no by 1/0, and then reclassify them into factors.

```{r}
df <- df %>%
  mutate(across(c("attrition","over_time"),
                ~ if_else(. == "Yes",1,0))) %>% 
  mutate(across(c("attrition","over_time"),
                ~ as.factor(.)))
```

We continue by reclassifying the nominal and the ordinal variables as factors. For the ordinal vectors we make sure that the order is kept.

```{r}
df <- df %>%  
  mutate(across(c("department", "education_field",
                  "job_role", "marital_status"),~ as.factor(.))) %>%
  mutate(across(c("environment_satisfaction", "job_satisfaction",
                  "relationship_satisfaction",
                  "work_life_balance","business_travel", "education" ,
                  "job_involvement","job_level", "stock_option_level",
                  "performance_rating"),
                ~ as.ordered(.))) %>%
  mutate(business_travel = factor(business_travel, ordered = TRUE,
                                  levels = c("Non-Travel",
                                             "Travel_Rarely","Travel_Frequently")))
```

Now we put the different types of variables into groups.
```{r}
numerical <- c("age", "distance_from_home","hourly_rate",
               "daily_rate","monthly_rate","monthly_income",
               "percent_salary_hike","years_at_company",     "years_in_current_role","years_since_last_promotion",
               "years_with_curr_manager","total_working_years",
               "num_companies_worked","training_times_last_year")

numerical1 <- c("age", "distance_from_home","hourly_rate",
               "daily_rate")
numerical2 <- c("monthly_rate","monthly_income",
               "percent_salary_hike","years_at_company")
numerical3 <- c("years_in_current_role","years_since_last_promotion",
               "years_with_curr_manager","total_working_years")
numerical4 <- c("num_companies_worked","training_times_last_year") 

categorical <- c("gender","over_time","department",
                 "education_field", "job_role", "marital_status")

ordinal1 <- c("environment_satisfaction", "job_satisfaction",
             "relationship_satisfaction","work_life_balance")
ordinal2 <-  c("job_involvement","performance_rating",
             "business_travel", "education")
ordinal3 <- c("job_level","stock_option_level")

ordinal <- c("environment_satisfaction", "job_satisfaction",
             "relationship_satisfaction","work_life_balance",
             "job_involvement","performance_rating",
             "business_travel", "education","job_level",
             "stock_option_level")
```

Then we continue by creating a train/test split. We set the seed for reproducibility.
```{r}
#creating a train/test split

# Setting the seed for reproducibility
set.seed(1234)

# Creating a train/test split using the `rsample` package
library(rsample)
split <- initial_split(df, prop = 0.8, strata = attrition)
train <- training(split)
test <- testing(split)
```


**Descriptive analysis**
We start by looking at the dependent variable in our regression, which is the attrition rate.This is the number of employees that have left te firm divided by the total number of employees at the firm.

```{r}

attrition_counts <- data %>%
  count(attrition)

pie_chart <- ggplot(attrition_counts, aes(x = "", y = n, fill = attrition)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar("y", start = 0) +
  geom_text(aes(label = paste0(n)), position = position_stack(vjust = 0.5)) +
  labs(title = "Attrition") +
  theme_void()

# Display the pie chart
pie_chart
```

We continue by making a selection of some of the variables, which we selected to use for our analysis on job search prediction. We made this selection by going through literature, and see which according to them, had the most significant influence on the attrition rate. Below you see visualisations of some of those selected variables.

```{r}
subset_data <- data %>%
  select(years_in_current_role, job_role, monthly_income, job_satisfaction, work_life_balance, age, gender)

summary_table <- subset_data %>%
  select(years_in_current_role, monthly_income, job_satisfaction, work_life_balance, age) %>%
  pivot_longer(cols = everything(), names_to = "variable", values_to = "value") %>%
  group_by(variable) %>%
  summarize(mean = mean(value), sd = sd(value)) %>%
  pivot_longer(cols = c("mean", "sd"), names_to = "statistic", values_to = "value") %>%
  pivot_wider(names_from = variable, values_from = value) %>%
  kable()

boxplot_data <- subset_data %>%
  filter(gender != "") %>%
  ggplot(aes(x = gender, y = years_in_current_role, fill = gender)) +
  geom_boxplot() +
  labs(x = "Gender", y = "Years in Current Role", title = "Years in Current Role by Gender") +
  theme_minimal()

histogram_data <- subset_data %>%
  ggplot(aes(x = monthly_income)) +
  geom_histogram(binwidth = 500, fill = "#69b3a2", color = "white") +
  labs(x = "Monthly Income", y = "Count", title = "Histogram of Monthly Income") +
  theme_minimal()

job_counts <- subset_data %>%
  group_by(job_role) %>%
  summarize(count = n()) %>%
  arrange(desc(count))

job_role_table <- kable(job_counts, 
                         caption = "Counts of Job Roles", 
                         col.names = c("Job Role", "Count"))
summary_table
boxplot_data
histogram_data
job_role_table
```

Next we continue our analysis on job search prediction by building a model around it.
Here, we use the rpart library to build a decision tree model, which can be visualized using the rpart.plot library. We convert the "gender" variable to a factor, split the data into training and testing sets, and fit the model on the training data. We then predict on the testing set and evaluate the model using a confusion matrix and accuracy metric. Note that this is just one possible solution, and there are many other models and techniques you can use to predict "attrition" with these variables.

```{r}
# Build the decision tree model
dectreemodel <- rpart(attrition ~ years_in_current_role + job_role + monthly_income + job_satisfaction + work_life_balance + age + gender,
               data = train,
               method = "class")

# Plot the decision tree
rpart.plot(dectreemodel)

# Predict on the testing set
predictions <- predict(dectreemodel, newdata = test, type = "class")

# Evaluate the model
confusion_matrix <- table(predictions, test$attrition)
accuracy <- sum(diag(confusion_matrix)) / sum(confusion_matrix)
print(confusion_matrix)
print(paste0("Accuracy: ", round(accuracy, 2)))

```



Here we see that the decision tree has an accuracy of around 82%. Since we are not satisfied by this result, we want to to further develop our prediction. We start by looking whether there are variables that have a significant influence on attrition which we may not have included in our analysis. 
In order to find this out, we visualize all the the variables to see whether te variables have an influence on the attritionrate.

We start with the numerical variabels. We visualize them by plotting a density function and differentate between attrition being 0 or 1.

```{r}
# set up the general "settings" for the density plots
colors <- c("blue","red")

# Generate the density plots (part 1)
plots_n1 <- lapply(numerical1, function(v) {
  ggplot(df, aes_string(x = v, fill = "attrition")) +
    geom_density(alpha = 0.5) +
    scale_fill_manual(values = colors) +
    ggtitle(v) +
    theme_bw() +
    theme(plot.title = element_text(hjust = 0.5),
          axis.title = element_text(size = 10),
          legend.position = "bottom",
          legend.title = element_blank(),
          legend.text = element_text(size = 10))
})

# show the density plots in a 2x2 grid
gridExtra::grid.arrange(grobs = plots_n1, ncol = 2)
```

```{r}
# Generate the density plots (part 2)

plots_n2 <- lapply(numerical2, function(v) {
  ggplot(df, aes_string(x = v, fill = "attrition")) +
    geom_density(alpha = 0.5) +
    scale_fill_manual(values = colors) +
    ggtitle(v) +
    theme_bw() +
    theme(plot.title = element_text(hjust = 0.5),
          axis.title = element_text(size = 10),
          legend.position = "bottom",
          legend.title = element_blank(),
          legend.text = element_text(size = 10))
})

# show the density plots in a 2x2 grid
gridExtra::grid.arrange(grobs = plots_n2, ncol = 2)
```

```{r}
# Generate the density plots (part 3)

plots_n3 <- lapply(numerical3, function(v) {
  ggplot(df, aes_string(x = v, fill = "attrition")) +
    geom_density(alpha = 0.5) +
    scale_fill_manual(values = colors) +
    ggtitle(v) +
    theme_bw() +
    theme(plot.title = element_text(hjust = 0.5),
          axis.title = element_text(size = 10),
          legend.position = "bottom",
          legend.title = element_blank(),
          legend.text = element_text(size = 10))
})

# Save the density plots to a PDF file
gridExtra::grid.arrange(grobs = plots_n3, ncol = 2)
```

```{r}
# Generate the density plots (part 4)

plots_n4 <- lapply(numerical4, function(v) {
  ggplot(df, aes_string(x = v, fill = "attrition")) +
    geom_density(alpha = 0.5) +
    scale_fill_manual(values = colors) +
    ggtitle(v) +
    theme_bw() +
    theme(plot.title = element_text(hjust = 0.5),
          axis.title = element_text(size = 10),
          legend.position = "bottom",
          legend.title = element_blank(),
          legend.text = element_text(size = 10))
})

# show the density plots in a 2x2 grid
gridExtra::grid.arrange(grobs = plots_n4, ncol = 2)
```

Now we continue by visualising the ordinal variables. We decided upon visualising those using stacked bar charts.

```{r}
summarise_att <- function(tbl) {
  tbl %>%
    summarise(n = n(),
              att = sum(attrition == 1),
              pct_att = att / n)
}

plot_bar <- function(tbl, var1) {
  var1name <- as.name(var1)
  tbl %>%
    group_by({{ var1name }}) %>%
    summarise_att() %>%
    mutate({{ var1name }} := paste0({{ var1name }}, "\n(", n, ")")) %>%
    ggplot(aes(x = {{ var1name }}, y = pct_att)) +
    geom_col(aes(fill = {{ var1name }}), width = 0.75, color = "black") +
    geom_hline(yintercept = mean(tbl$attrition), linetype = 3) +
    theme(legend.position = "none") +
    scale_y_continuous(labels = scales::percent_format()) +
    labs(title = paste("Attrition rate by", var1),
         x = NULL,
         y = "Attrition rate (%)")
}


# Create a list of the plots
plots_o1 <- lapply(ordinal1, function(x) plot_bar(df, x))
plots_o2 <- lapply(ordinal2, function(x) plot_bar(df, x))
plots_o3 <- lapply(ordinal3, function(x) plot_bar(df, x))

# Arrange the plots in a 2x5 grid
grid.arrange(grobs = plots_o1, ncol = 2)
grid.arrange(grobs = plots_o2, ncol = 2)
grid.arrange(grobs = plots_o3, ncol = 2)
```

Now we end with the categorical variables.
```{r}
summarise_att <- function(tbl) {
  tbl %>%
    summarise(n = n(),
              att = sum(attrition == 1),
              pct_att = att / n)
}

plot_bar <- function(tbl, var1) {
  var1name <- as.name(var1)
  tbl %>%
    group_by({{ var1name }}) %>%
    summarise_att() %>%
    mutate({{ var1name }} := paste0({{ var1name }}, "\n(", n, ")")) %>%
    ggplot(aes(x = {{ var1name }}, y = pct_att)) +
    geom_col(aes(fill = {{ var1name }}), width = 0.75, color = "black") +
    geom_hline(yintercept = mean(tbl$attrition), linetype = 3) +
    theme(legend.position = "none") +
    scale_y_continuous(labels = scales::percent_format()) +
    labs(title = paste("Attrition rate by", var1),
         x = NULL,
         y = "Attrition rate (%)")
}

plots_c <- lapply(categorical, function(x) plot_bar(df, x))
grid.arrange(grobs = plots_c, ncol = 2)

```



As we tought that the job level compared to the educational level might influence whether an employee will churn or not, we make a new variable which shows this relation. 

```{r}
# Load the necessary package
library(dplyr)

# Create a new binary variable indicating if job level is lower than education level
df <- df %>%
  mutate(job_level_below_education = ifelse(job_level < education, 1, 0))

# Build a logistic regression model to predict attrition 
model <- glm(attrition ~ job_level_below_education, data = df, family = binomial())

# Display model summary
summary(model)

# Calculate the number of people with attrition = 1 who also have job_level_below_education = 1
n <- sum(df$attrition == 1 & df$job_level_below_education == 1)
cat("Number of people with attrition = 1 and job_level_below_education = 1:", n)

```

```{r}
# create a contingency table
table(df$attrition, df$job_level_below_education)

# create a mosaic plot
mosaicplot(table(df$attrition, df$job_level_below_education), 
           main = "Attrition vs. Job Level Below Education", 
           color = c("#00BFC4", "#F8766D"), 
           ylab = "Attrition", xlab = "Job Level Below Education")

```


```{r}
ggplot(df, aes(x = factor(job_level), fill = factor(attrition))) + 
  geom_bar(position = "fill") +
  facet_wrap(~education) +
  labs(x = "Job Level", y = "Proportion", fill = "Attrition") +
  scale_fill_manual(values = c("green", "red"), labels = c("No", "Yes"))
```

```{r}
# Define color palette
my_colors <- colorRampPalette(c("#009E73", "#F0E442", "#0072B2"))(100)

# Set graphical parameters
par(mar = c(0, 0, 0, 0), bg = "#F7FBFF")

# Plot correlation matrix with customized parameters
corrplot(cor(df[,numerical]), method="circle", order="hclust",
         col=my_colors, tl.col="#696969", tl.srt=45, tl.cex=0.8,
         addCoef.col="#333333", addCoefasPercent=TRUE)
```

```{r}
# Create a new data frame with one-hot encoded variables
df_encoded <- as.data.frame(model.matrix(~., data=df[,categorical]))

# Generate a correlation plot using the encoded data
col <- colorRampPalette(c("#4B0082", "#00FF00", "#FFA500", "#FF0000"))(100)
corrplot.mixed(cor(df_encoded), lower.col = col, upper.col = "blue", tl.col = "black", tl.cex=0.8, tl.srt=45, tl.pos = "lt", number.cex = 0.4)

```



