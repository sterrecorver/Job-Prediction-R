---
title: "Project"
author: "Sterre Corver and Tim van der Valk"
date: "2023-02-22"
output:
  prettydoc::html_pretty:
      theme: leonids
      highlights: github
---

```{r setup, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r echo=FALSE}
library(janitor)
library(tidyverse)
library(ggplot2)
library(dplyr)
library(knitr)
library(tidyr)
library(scales)
library(tidymodels)
library(rpart)
library(rpart.plot)
library(ggcorrplot)
library(corrplot)
library(gridExtra)
library(glue)
library(rsample)
library(rpart)
library(caret)
```

**data preparation**
```{r}
# open the dataset and make sure there is a "_" placed between te words of the features
data <- read.csv("job_search_dataset.csv") %>% clean_names()
```

```{r}
# remove the features "employee_count", "standard_hours", "over18"
df <- subset(data, select = -c(employee_count, standard_hours, over18))
```

```{r}
# change binary variables from yes/no to 1/0, and mutate as factors
df <- df %>%
  mutate(across(c("attrition","over_time"),
                ~ if_else(. == "Yes",1,0))) %>% 
  mutate(across(c("attrition","over_time"),
                ~ as.factor(.)))
```

```{r}
# reclassify the nominal and the ordinal variables as factors, keeping the order
df <- df %>%  
  mutate(across(c("department", "education_field",
                  "job_role", "marital_status"),~ as.factor(.))) %>%
  mutate(across(c("environment_satisfaction", "job_satisfaction",
                  "relationship_satisfaction",
                  "work_life_balance","business_travel", "education" ,
                  "job_involvement","job_level", "stock_option_level",
                  "performance_rating"),
                ~ as.ordered(.))) %>%
  mutate(business_travel = factor(business_travel, ordered = TRUE,
                                  levels = c("Non-Travel",
                                             "Travel_Rarely","Travel_Frequently")))
```

```{r}
# put the different types of variables into groups, for the plots later
numerical <- c("age", "distance_from_home","hourly_rate",
               "daily_rate","monthly_rate","monthly_income",
               "percent_salary_hike","years_at_company",     "years_in_current_role","years_since_last_promotion",
               "years_with_curr_manager","total_working_years",
               "num_companies_worked","training_times_last_year")

numerical1 <- c("age", "distance_from_home","hourly_rate",
               "daily_rate")
numerical2 <- c("monthly_rate","monthly_income",
               "percent_salary_hike","years_at_company")
numerical3 <- c("years_in_current_role","years_since_last_promotion",
               "years_with_curr_manager","total_working_years")
numerical4 <- c("num_companies_worked","training_times_last_year") 

categorical <- c("gender","over_time","department",
                 "education_field", "job_role", "marital_status")

ordinal <- c("environment_satisfaction", "job_satisfaction",
             "relationship_satisfaction","work_life_balance",
             "job_involvement","performance_rating",
             "business_travel", "education","job_level",
             "stock_option_level")
ordinal1 <- c("environment_satisfaction", "job_satisfaction",
             "relationship_satisfaction","work_life_balance")
ordinal2 <-  c("job_involvement","performance_rating",
             "business_travel", "education")
ordinal3 <- c("job_level","stock_option_level")
```


```{r}
# create a new variable called total_satisfaction
df$total_satisfaction <- df$environment_satisfaction + df$job_satisfaction + df$relationship_satisfaction

# convert the variable to a factor with levels 3 to 12
df$total_satisfaction <- factor(df$total_satisfaction, levels = 3:12)
```

```{r}
# create a new binary variable indicating if job level is lower than education level
df <- df %>%
  mutate(job_level_below_education = ifelse(job_level < education, 1, 0))

# build a logistic regression model to predict attrition with the variable "job_level_below_education"
model <- glm(attrition ~ job_level_below_education, data = df, family = binomial())

# display model summary
summary(model)

# calculate the number of people with attrition = 1 who also have job_level_below_education = 1
n <- sum(df$attrition == 1 & df$job_level_below_education == 1)
cat("Number of people with attrition = 1 and job_level_below_education = 1:", n)

```

```{r}
# set the seed for reproducibility
set.seed(1234)

# create a train/test split using the `rsample` package
split <- initial_split(df, prop = 0.8, strata = attrition)
train <- training(split)
test <- testing(split)
```

**Descriptive analysis**
```{r}
# count attrition for the pie chart
attrition_counts <- data %>%
  count(attrition)

# create pie_chart function
pie_chart <- ggplot(attrition_counts, aes(x = "", y = n, fill = attrition)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar("y", start = 0) +
  geom_text(aes(label = paste0(n)), position = position_stack(vjust = 0.5)) +
  labs(title = "Attrition") +
  theme_void()

# display the pie chart
pie_chart
```

```{r}
# select the relevant features according to literature
subset_data <- data %>%
  select(years_in_current_role, job_role, monthly_income, job_satisfaction, work_life_balance, age, gender)

# summarise the values of the selected features
summary_table <- subset_data %>%
  select(years_in_current_role, monthly_income, job_satisfaction, work_life_balance, age) %>%
  pivot_longer(cols = everything(), names_to = "variable", values_to = "value") %>%
  group_by(variable) %>%
  summarize(mean = mean(value), sd = sd(value)) %>%
  pivot_longer(cols = c("mean", "sd"), names_to = "statistic", values_to = "value") %>%
  pivot_wider(names_from = variable, values_from = value) %>%
  kable()

# create boxplot of gender vs years in current role
boxplot_data <- subset_data %>%
  filter(gender != "") %>%
  ggplot(aes(x = gender, y = years_in_current_role, fill = gender)) +
  geom_boxplot() +
  labs(x = "Gender", y = "Years in Current Role", title = "Years in Current Role by Gender") +
  theme_minimal()

# create histogram with distribution of montly income
histogram_data <- subset_data %>%
  ggplot(aes(x = monthly_income)) +
  geom_histogram(binwidth = 500, fill = "#69b3a2", color = "white") +
  labs(x = "Monthly Income", y = "Count", title = "Histogram of Monthly Income") +
  theme_minimal()

# count job_roles
job_counts <- subset_data %>%
  group_by(job_role) %>%
  summarize(count = n()) %>%
  arrange(desc(count))

# create table with jobroles
job_role_table <- kable(job_counts, 
                         caption = "Counts of Job Roles", 
                         col.names = c("Job Role", "Count"))

# show the created figures
summary_table
boxplot_data
histogram_data
job_role_table
```


**Model based on literature**
```{r}
# Build the decision tree model
dectreemodel <- rpart(attrition ~ years_in_current_role + job_role + monthly_income + job_satisfaction + work_life_balance + age + gender,
               data = train,
               method = "class")

# Plot the decision tree
rpart.plot(dectreemodel)

# Predict on the testing set
predictions <- predict(dectreemodel, newdata = test, type = "class")

# Evaluate the model
confusion_matrix <- table(predictions, test$attrition)
accuracy <- sum(diag(confusion_matrix)) / sum(confusion_matrix)
print(confusion_matrix)
print(paste0("Accuracy: ", round(accuracy, 2)))

```

```{r}
# Define the training control
ctrl <- trainControl(method = "cv", number = 10, verboseIter = FALSE)

# Train the model with cross-validation
dectreemodelcv <- train(attrition ~ years_in_current_role + job_role + monthly_income + job_satisfaction + work_life_balance + age + gender,
               data = train,
               method = "rpart",
               trControl = ctrl,
               tuneLength = 10)

# Print the cross-validation results
print(dectreemodelcv)

```

```{r}
# set up the general "settings" for the density plots we create of attrition against all our variables
colors <- c("blue","red")

# generate the density plots (part 1)
plots_n1 <- lapply(numerical1, function(v) {
  ggplot(df, aes_string(x = v, fill = "attrition")) +
    geom_density(alpha = 0.5) +
    scale_fill_manual(values = colors) +
    ggtitle(v) +
    theme_bw() +
    theme(plot.title = element_text(hjust = 0.5),
          axis.title = element_text(size = 10),
          legend.position = "bottom",
          legend.title = element_blank(),
          legend.text = element_text(size = 10))
})

# show the density plots in a 2x2 grid
gridExtra::grid.arrange(grobs = plots_n1, ncol = 2)

# generate the density plots (part 2)
plots_n2 <- lapply(numerical2, function(v) {
  ggplot(df, aes_string(x = v, fill = "attrition")) +
    geom_density(alpha = 0.5) +
    scale_fill_manual(values = colors) +
    ggtitle(v) +
    theme_bw() +
    theme(plot.title = element_text(hjust = 0.5),
          axis.title = element_text(size = 10),
          legend.position = "bottom",
          legend.title = element_blank(),
          legend.text = element_text(size = 10))
})

# show the density plots in a 2x2 grid
gridExtra::grid.arrange(grobs = plots_n2, ncol = 2)

# generate the density plots (part 3)
plots_n3 <- lapply(numerical3, function(v) {
  ggplot(df, aes_string(x = v, fill = "attrition")) +
    geom_density(alpha = 0.5) +
    scale_fill_manual(values = colors) +
    ggtitle(v) +
    theme_bw() +
    theme(plot.title = element_text(hjust = 0.5),
          axis.title = element_text(size = 10),
          legend.position = "bottom",
          legend.title = element_blank(),
          legend.text = element_text(size = 10))
})

# save the density plots to a PDF file
gridExtra::grid.arrange(grobs = plots_n3, ncol = 2)

# generate the density plots (part 4)
plots_n4 <- lapply(numerical4, function(v) {
  ggplot(df, aes_string(x = v, fill = "attrition")) +
    geom_density(alpha = 0.5) +
    scale_fill_manual(values = colors) +
    ggtitle(v) +
    theme_bw() +
    theme(plot.title = element_text(hjust = 0.5),
          axis.title = element_text(size = 10),
          legend.position = "bottom",
          legend.title = element_blank(),
          legend.text = element_text(size = 10))
})

# show the density plots in a 2x2 grid
gridExtra::grid.arrange(grobs = plots_n4, ncol = 2)
```

```{r}
# create function to calculate percentage of attrition
summarise_att <- function(tbl) {
  tbl %>%
    summarise(n = n(),
              att = sum(attrition == 1),
              pct_att = att / n)
}

# create plot bar to show the attrition rate against the ordinal and the categorical variables
plot_bar <- function(tbl, var1) {
  var1name <- as.name(var1)
  tbl %>%
    group_by({{ var1name }}) %>%
    summarise_att() %>%
    mutate({{ var1name }} := paste0({{ var1name }}, "\n(", n, ")")) %>%
    ggplot(aes(x = {{ var1name }}, y = pct_att)) +
    geom_col(aes(fill = {{ var1name }}), width = 0.75, color = "black") +
    geom_hline(yintercept = mean(tbl$attrition), linetype = 3) +
    theme(legend.position = "none") +
    scale_y_continuous(labels = scales::percent_format()) +
    labs(title = paste("Attrition rate by", var1),
         x = NULL,
         y = "Attrition rate (%)")
}


# create a list of the plots of the ordinal variables
plots_o1 <- lapply(ordinal1, function(x) plot_bar(df, x))
plots_o2 <- lapply(ordinal2, function(x) plot_bar(df, x))
plots_o3 <- lapply(ordinal3, function(x) plot_bar(df, x))

# arrange the plotlists in a 2x2 grid
grid.arrange(grobs = plots_o1, ncol = 2)
grid.arrange(grobs = plots_o2, ncol = 2)
grid.arrange(grobs = plots_o3, ncol = 2)

# create a list of the plots of the categorical variables
plots_c <- lapply(categorical, function(x) plot_bar(df, x))

# arrange the plotlists in a 2x2 grid
grid.arrange(grobs = plots_c, ncol = 2)

```



```{r}
# create a contingency table
table(df$attrition, df$job_level_below_education)

# create a mosaic plot
mosaicplot(table(df$attrition, df$job_level_below_education), 
           main = "Attrition vs. Job Level Below Education", 
           color = c("blue", "red"), 
           ylab = "Attrition", xlab = "Job Level Below Education")

```

```{r}
# 
ggplot(df, aes(x = factor(job_level), fill = factor(attrition))) + 
  geom_bar(position = "fill") +
  facet_wrap(~education) +
  labs(x = "Job Level", y = "Proportion", fill = "Attrition") +
  scale_fill_manual(values = c("blue", "red"), labels = c("No", "Yes"))
```

```{r}
# define color palette
my_colors <- colorRampPalette(c("#009E73", "#F0E442", "#0072B2"))(100)

# set graphical parameters
par(mar = c(0, 0, 0, 0), bg = "#F7FBFF")

# plot correlation matrix with customized parameters
corrplot(cor(df[,numerical]), method="circle", order="hclust",
         col=my_colors, tl.col="#696969", tl.srt=45, tl.cex=0.8,
         addCoef.col="#333333", addCoefasPercent=TRUE)
```

```{r}
# create a new data frame with one-hot encoded variables
df_encoded <- as.data.frame(model.matrix(~., data=df[,categorical]))

# generate a correlation plot using the encoded data
col <- colorRampPalette(c("#4B0082", "#00FF00", "#FFA500", "#FF0000"))(100)
corrplot.mixed(cor(df_encoded), lower.col = col, upper.col = "blue", tl.col = "black", tl.cex=0.8, tl.srt=45, tl.pos = "lt", number.cex = 0.4)

```

create a new prediction model based on the data exploring

```{r}
# fit the logistic regression model
logisticmodel <- glm(attrition ~ total_working_years + job_involvement + business_travel + job_level + stock_option_level + over_time + years_in_current_role + monthly_income + marital_status + work_life_balance + job_satisfaction + relationship_satisfaction + environment_satisfaction,
                     data = train,
                     family = binomial())

# predict on the testing set
probabilities <- predict(logisticmodel, newdata = test, type = "response")

# convert probabilities to binary predictions
predictions <- ifelse(probabilities > 0.5, 1, 0)

# evaluate the model
confusion_matrix <- table(predictions, test$attrition)
accuracy <- sum(diag(confusion_matrix)) / sum(confusion_matrix)
print(confusion_matrix)
print(paste0("Accuracy: ", round(accuracy, 2)))
```

robustness check for model -removed years_at_company + 
```{r}
# load the necessary library
library(caret)

# Define the training control
train_control <- trainControl(method = "cv", number = 10)

# Train the logistic regression model using cross-validation
logistic_model_cv <- train(attrition ~ total_working_years + job_involvement + business_travel + job_level + stock_option_level + over_time + years_in_current_role + monthly_income + marital_status  + work_life_balance + job_satisfaction + relationship_satisfaction + environment_satisfaction,
                           data = train,
                           method = "glm",
                           family = binomial(),
                           trControl = train_control)

# Print the cross-validation results
print(logistic_model_cv)

```

```{r}

```





